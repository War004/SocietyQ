package com.CodeShark.SocietyQ.data


import android.content.Context
import android.content.SharedPreferences
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import android.util.Base64
import java.nio.charset.Charset
import java.security.KeyStore
import javax.crypto.Cipher
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey
import javax.crypto.spec.GCMParameterSpec
import androidx.core.content.edit

/**
 * Utility class to manage user login status using SharedPreferences,
 * with the username encrypted using the Android Keystore system.
 */
object UserPreferences {

    private const val PREFS_NAME = "SocietyQPrefs"
    // Keys for SharedPreferences storage
    private const val KEY_ENCRYPTED_USERNAME = "encrypted_username"
    private const val KEY_ENCRYPTION_IV = "encryption_iv" // Initialization Vector

    // Keystore and Encryption Constants
    private const val ANDROID_KEYSTORE = "AndroidKeyStore"
    private const val KEY_ALIAS = "SocietyQUserKey" // Alias for the key in Keystore
    private const val TRANSFORMATION = KeyProperties.KEY_ALGORITHM_AES + "/" +
            KeyProperties.BLOCK_MODE_GCM + "/" + // GCM provides authenticated encryption
            KeyProperties.ENCRYPTION_PADDING_NONE
    private const val GCM_TAG_LENGTH = 128 // Standard GCM tag length in bits

    // Function to get SharedPreferences instance
    private fun getPrefs(context: Context): SharedPreferences {
        return context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
    }

    // --- Keystore Key Management ---

    /**
     * Gets the SecretKey from Keystore or generates a new one if it doesn't exist.
     */
    @Throws(Exception::class)
    private fun getOrCreateSecretKey(): SecretKey {
        val keyStore = KeyStore.getInstance(ANDROID_KEYSTORE)
        keyStore.load(null) // Load the Keystore

        keyStore.getKey(KEY_ALIAS, null)?.let { key ->
            // Key already exists
            return key as SecretKey
        }

        // Key doesn't exist, generate a new one
        val keyGenSpec = KeyGenParameterSpec.Builder(
            KEY_ALIAS,
            KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
        )
            .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
            .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
            .setKeySize(256) // AES-256
            // Optional: Require user authentication (e.g., fingerprint) to use the key
            // .setUserAuthenticationRequired(true)
            // .setUserAuthenticationValidityDurationSeconds(60) // Key valid for 60s after auth
            .build()

        val keyGenerator = KeyGenerator.getInstance(
            KeyProperties.KEY_ALGORITHM_AES,
            ANDROID_KEYSTORE
        )
        keyGenerator.init(keyGenSpec)
        return keyGenerator.generateKey()
    }

    // --- Encryption / Decryption ---

    /**
     * Encrypts the username using the key from Keystore.
     *
     * @param username The plain text username.
     * @return Pair containing Base64 encoded encrypted data and Base64 encoded IV, or null on failure.
     */
    private fun encryptUsername(username: String): Pair<String, String>? {
        return try {
            val secretKey = getOrCreateSecretKey()
            val cipher = Cipher.getInstance(TRANSFORMATION)
            cipher.init(Cipher.ENCRYPT_MODE, secretKey)

            val iv = cipher.iv // Get the Initialization Vector generated by the cipher
            val encryptedBytes = cipher.doFinal(username.toByteArray(Charset.forName("UTF-8")))

            // Encode bytes to Base64 strings for storage in SharedPreferences
            val encryptedBase64 = Base64.encodeToString(encryptedBytes, Base64.DEFAULT)
            val ivBase64 = Base64.encodeToString(iv, Base64.DEFAULT)

            Pair(encryptedBase64, ivBase64)
        } catch (e: Exception) {
            // Log error appropriately in a real app
            println("Encryption failed: ${e.message}")
            e.printStackTrace()
            null
        }
    }

    /**
     * Decrypts the username using the key from Keystore.
     *
     * @param encryptedBase64 Base64 encoded encrypted username.
     * @param ivBase64 Base64 encoded Initialization Vector.
     * @return The decrypted username, or null if decryption fails.
     */
    private fun decryptUsername(encryptedBase64: String?, ivBase64: String?): String? {
        if (encryptedBase64 == null || ivBase64 == null) {
            return null // Not logged in or data missing
        }

        return try {
            val secretKey = getOrCreateSecretKey() // Retrieve the same key
            val cipher = Cipher.getInstance(TRANSFORMATION)

            // Decode Base64 strings back to byte arrays
            val encryptedBytes = Base64.decode(encryptedBase64, Base64.DEFAULT)
            val iv = Base64.decode(ivBase64, Base64.DEFAULT)

            val spec = GCMParameterSpec(GCM_TAG_LENGTH, iv)
            cipher.init(Cipher.DECRYPT_MODE, secretKey, spec)

            val decryptedBytes = cipher.doFinal(encryptedBytes)
            String(decryptedBytes, Charset.forName("UTF-8"))
        } catch (e: Exception) {
            // Log error appropriately (e.g., Key invalidated, bad data)
            println("Decryption failed: ${e.message}")
            e.printStackTrace()
            // Treat decryption failure as logged out
            null
        }
    }

    // --- Public API ---

    /**
     * Encrypts and saves the username and IV to indicate the user is logged in.
     *
     * @param context The application context.
     * @param username The username to save.
     * @return True if saving was successful, false otherwise.
     */
    fun saveLogin(context: Context, username: String): Boolean {
        val encryptedPair = encryptUsername(username)
        return if (encryptedPair != null) {
            getPrefs(context).edit()
                .putString(KEY_ENCRYPTED_USERNAME, encryptedPair.first) // Save encrypted data
                .putString(KEY_ENCRYPTION_IV, encryptedPair.second)      // Save IV
                .apply()
            true
        } else {
            // Encryption failed, clear any potentially stale data
            logout(context)
            false
        }
    }

    /**
     * Retrieves and decrypts the logged-in username.
     *
     * @param context The application context.
     * @return The decrypted username, or null if no user is logged in or decryption fails.
     */
    fun getLoggedInUsername(context: Context): String? {
        val prefs = getPrefs(context)
        val encryptedUser = prefs.getString(KEY_ENCRYPTED_USERNAME, null)
        val iv = prefs.getString(KEY_ENCRYPTION_IV, null)
        return decryptUsername(encryptedUser, iv)
    }

    /**
     * Checks if a user is currently logged in by attempting to decrypt the stored username.
     *
     * @param context The application context.
     * @return True if a username is successfully decrypted and is not blank, false otherwise.
     */
    fun isLoggedIn(context: Context): Boolean {
        // Attempt to decrypt. If successful and not blank, user is logged in.
        return !getLoggedInUsername(context).isNullOrBlank()
    }

    /**
     * Clears the encrypted username and IV from SharedPreferences, effectively logging the user out.
     * The Keystore key itself remains but is no longer associated with stored login data.
     *
     * @param context The application context.
     */
    fun logout(context: Context) {
        getPrefs(context).edit() {
            remove(KEY_ENCRYPTED_USERNAME)
                .remove(KEY_ENCRYPTION_IV)
        }
    }
}
